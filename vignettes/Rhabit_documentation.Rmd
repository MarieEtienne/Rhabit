---
title: "Mapping animal's habitat using the **Rhabit** package"
author: "Pierre Gloaguen, ThÃ©o Michelot and Marie-Pierre Etienne"
date: "11 octobre 2018"
output: 
  pdf_document:
    fig_caption: false
editor_options: 
  chunk_output_type: console
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, comment = NA, message = F, warning = F,
                      fig.align = "center", fig.height = 5, fig.height = 3)
library(viridis)
library(ggplot2)
library(gridExtra)
library(abind)
```

\begin{center}
\includegraphics[width = 0.5\textwidth]{rabbit_V2.png}

\textit{Ideas are like rabbits. You get a couple and learn how to handle them, and pretty soon you have a dozen.}

\textbf{John Steinbeck}
\end{center}

# Introduction

This document presents briefly an application using R packages `RLangevinMM`
and `Rhabit` to simulate according to the Langevin movement model, and to 
perform utilization distribution estimation using trajectory data and 
covariate maps.

### Loading packages and data

First, one need to load the packages

```{r libraries}
library(Rhabit)
```

The `Rhabit` package contains two toy data sets that will be used in this
document

```{r loadingData}
data("covariates", package = "Rhabit")
data("tracks", package = "Rhabit")
```

## Covariates

`covariates` is a list containing 2 elements (the number of covariates).
Each element is a "raster-like" list containing three elements, namely:

```{r namesCovariates, echo = F}
names(covariates[[1]])
```

The first two define coordinates on a grid, and the last one a matrix of 
covariate values on this grid.

```{r dims}
length(covariates[[1]]$x)
length(covariates[[1]]$y)
dim(covariates[[1]]$z)
```


Each element of covariate can be transformed to a `data.frame` (to ease plots 
with `ggplot2`) using the `rasterToGGplot` function.

```{r rasterToGGplot}
cov1_df <- Rhabit::rasterToGGplot(covariates[[1]])
head(cov1_df)
dim(cov1_df)
```

This function also can admit `level` argument, specifying the covariate number.

```{r}
J <- length(covariates) # number of covariates
levels <- factor(paste("Covariate", 1:J), levels = paste("Covariate", 1:J))
cov_df <- do.call(rbind.data.frame,
                 lapply(1:J,
                        function(j){
                          Rhabit::rasterToGGplot(covariates[[j]], levels[j])
                        }))
summary(cov_df)
```

The two considered covariates are the following:

```{r plot, echo = F, fig.align="center"}
ggopts <- theme_light()+theme(text = element_text(size = 20),
                axis.text = element_blank(),
                axis.title = element_blank(),
                legend.key.height= unit(3, "line"),
                strip.background = element_rect(fill="white",colour = "grey") ,
                strip.text = element_text(size = 25, face = "bold", color = "black"))
my_plot <- ggplot(cov_df, aes(x,y)) + geom_raster(aes(fill = val)) +
  coord_equal() + scale_fill_viridis(name = "") + facet_wrap(level~.) +
  ggopts
panel_height <- (unit(1,"npc") - sum(ggplotGrob(my_plot)[["heights"]][-3])
                 - unit(1,"line"))
my_plot +  guides(fill= guide_colorbar(barheight=panel_height))
```

## Tracks

`tracks` is `data.frame` containing three columns:

```{r headTracks}
head(tracks)
```

One can plot the following tracks:

```{r plotTracks, echo = F}
ggplot(tracks, aes(x, y)) + geom_path() + ggopts
```

It is assumed here that this track ia realization of a stochastic process 
$(X_t)_{t\geq 0}$ such that:
$$\text{d}X_t = \frac{\gamma^2}{2}\nabla \log \pi(X_t) \text{d}t
+ \gamma\text{d}W_t.$$
where $\pi()$ is the utilization distribution of the individual.

This equation defines the Langevin movement model.

## Utilization distribution

The trajectory showed above was simulated according to the Langevin movement 
model where the utilization distribution satisfies a common resource selection 
function, namely:
$$\pi(z) = \exp(\beta_1c_1(z) + \beta_2c_2(z))$$
where $c_1(z)$ and $c_2(z)$ are the two spatial covariates shown above.

For the simulation, $\beta_1$ and $\beta_2$ where chosen equal to 1.

We represent here the utilization distribution, together with the trajectory:
```{r trajUD, echo = F}
beta_true <- c(1, 1)
ud_rast <- Rhabit::getUD(covariates, beta_true)
ud_df <- rasterToGGplot(ud_rast)
ggplot(ud_df, aes(x,y)) + geom_raster(aes(fill = val)) +
  coord_equal() + scale_fill_viridis(name = "Value") +
  geom_path(data = tracks[, 1:2]) +
  ggopts
```

# Estimation

<!-- We here perform the estimation on a subsample of 500 points (subsampled -->
<!-- at $\Delta = 0.4$). -->

<!-- ```{r, subsampling, echo = F} -->
<!-- n_obs <- 500 -->
<!-- sel <- floor(seq(1, nrow(tracks), length = n_obs)) -->
<!-- locs <- as.matrix(tracks[sel, c("x", "y")]) -->
<!-- times <- tracks[sel, "t"] -->
<!-- ``` -->

<!-- We define a `matrix` named `locs` with the position, and a `vector` times -->
<!-- with the corresponding sampling times -->
<!-- ```{r locsTimes} -->
<!-- head(locs) -->
<!-- dim(locs) -->
<!-- head(times) -->
<!-- ``` -->

<!-- An important thing to do is, given the covariates, to define a gradient array, -->
<!-- giving the approximate gradient at sampled points. -->

<!-- We first define the three important arguments -->

<!-- ```{r definingCovArray} -->
<!-- xgrid <- covariates[[1]]$x # x points for the grid -->
<!-- ygrid <- covariates[[1]]$y # y points -->
<!-- cov_array <- do.call(function(...) abind(..., along = 3), -->
<!--                      lapply(covariates, function(cov) cov$z)) -->
<!-- # Gathers covariates together in a 3d array. Each slice is a covariate -->
<!-- dim(cov_array) -->
<!-- ``` -->

<!-- The `covGradAtLocs` does the rest by computing the gradient of covariates at  -->
<!-- locations given by data. The interpolation is done using the `nloptr` library. -->

<!-- The result is a 3d array. Each slice is for a covariate, each row is for  -->
<!-- a location, and it has 2 columns (one per coordinate) -->

<!-- ```{r definingGradArray} -->
<!-- grad_array <- Rhabit::covGradAtLocs(locs, xgrid, ygrid,  -->
<!--                                          cov_array, lag_inter = 2) -->
<!-- dim(grad_array) -->
<!-- ``` -->

<!-- From that, one can has all the elements to use the main function -->

<!-- ```{r} -->
<!-- est <- Rhabit::langevinUD(locs, times, grad_array = grad_array) -->
<!-- print(est) -->
<!-- ``` -->

<!-- Here, the 95% confidence intervals covers the true value, that were respectively -->
<!-- 1, 1, and $\gamma^2 = 0.2$. -->

<!-- ## Estimation on a Brownian bridge -->

<!-- The precedent estimation basically compares a complicated model to a null hypothesis, -->
<!-- the brownian motion.  -->

<!-- In this section, we show that fitting the Langevin movement model to a Brownian -->
<!-- motion leads to estimated values non significantly different than 0. -->

<!-- ```{r estonBB} -->
<!-- set.seed(1)# repeatability -->
<!-- n_obs <- 500 -->
<!-- sel <- floor(seq(1, nrow(tracks), length = n_obs))# selected times -->
<!-- times <- tracks[sel, "t"]# using same time steps as beforre -->
<!-- #Simulation of brownian motion -->
<!-- # the 0.2 is the gamma^2 of the previous model -->
<!-- locs <- sapply(1:2, function(i)  -->
<!--   cumsum(c(tracks[1, i], rnorm(n_obs - 1, 0, sqrt(0.2 * diff(times)[1]))))) -->
<!-- # compoutes covariates gradient on the new locations -->
<!-- grad_array <- Rhabit::covGradAtLocs(locs, xgrid, ygrid,  -->
<!--                                          cov_array, lag_inter = 2) -->
<!-- (est <- langevinUD(locs, times, grad_array = grad_array)) -->
<!-- ``` -->

<!-- The estimate $\beta$ are not significantly different than 0! -->
